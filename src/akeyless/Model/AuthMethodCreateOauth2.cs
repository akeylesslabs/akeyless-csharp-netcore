/*
 * Akeyless API
 *
 * The purpose of this application is to provide access to Akeyless API.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@akeyless.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = akeyless.Client.OpenAPIDateConverter;

namespace akeyless.Model
{
    /// <summary>
    /// authMethodCreateOauth2 is a command that creates a new auth method that will be able to authenticate using Oauth2.
    /// </summary>
    [DataContract(Name = "authMethodCreateOauth2")]
    public partial class AuthMethodCreateOauth2 : IEquatable<AuthMethodCreateOauth2>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AuthMethodCreateOauth2" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected AuthMethodCreateOauth2() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="AuthMethodCreateOauth2" /> class.
        /// </summary>
        /// <param name="accessExpires">Access expiration date in Unix timestamp (select 0 for access without expiry date) (default to 0).</param>
        /// <param name="audience">The audience in the JWT.</param>
        /// <param name="auditLogsClaims">Subclaims to include in audit logs, e.g \&quot;- -audit-logs-claims email - -audit-logs-claims username\&quot;.</param>
        /// <param name="boundClientIds">The clients ids that the access is restricted to.</param>
        /// <param name="boundIps">A CIDR whitelist with the IPs that the access is restricted to.</param>
        /// <param name="cert">CertificateFile Path to a file that contain the certificate in a PEM format..</param>
        /// <param name="certFileData">CertificateFileData PEM Certificate in a Base64 format..</param>
        /// <param name="description">Auth Method description.</param>
        /// <param name="forceSubClaims">if true: enforce role-association must include sub claims.</param>
        /// <param name="gatewayUrl">Akeyless Gateway URL (Configuration Management port). Relevant only when the jwks-uri is accessible only from the gateway..</param>
        /// <param name="gwBoundIps">A CIDR whitelist with the GW IPs that the access is restricted to.</param>
        /// <param name="issuer">Issuer URL.</param>
        /// <param name="json">Set output format to JSON (default to false).</param>
        /// <param name="jwksJsonData">The JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server. base64 encoded string.</param>
        /// <param name="jwksUri">The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server. (required) (default to &quot;default_jwks_url&quot;).</param>
        /// <param name="jwtTtl">Jwt TTL (default to 0).</param>
        /// <param name="name">Auth Method name (required).</param>
        /// <param name="productType">Choose the relevant product type for the auth method [sm, sra, pm, dp, ca].</param>
        /// <param name="subclaimsDelimiters">A list of additional sub claims delimiters (relevant only for SAML, OIDC, OAuth2/JWT).</param>
        /// <param name="token">Authentication token (see &#x60;/auth&#x60; and &#x60;/configure&#x60;).</param>
        /// <param name="uidToken">The universal identity token, Required only for universal_identity authentication.</param>
        /// <param name="uniqueIdentifier">A unique identifier (ID) value should be configured for OAuth2, LDAP and SAML authentication method types and is usually a value such as the email, username, or upn for example. Whenever a user logs in with a token, these authentication types issue a \&quot;sub claim\&quot; that contains details uniquely identifying that user. This sub claim includes a key containing the ID value that you configured, and is used to distinguish between different users from within the same organization. (required).</param>
        public AuthMethodCreateOauth2(long accessExpires = 0, string audience = default(string), List<string> auditLogsClaims = default(List<string>), List<string> boundClientIds = default(List<string>), List<string> boundIps = default(List<string>), string cert = default(string), string certFileData = default(string), string description = default(string), bool forceSubClaims = default(bool), string gatewayUrl = default(string), List<string> gwBoundIps = default(List<string>), string issuer = default(string), bool json = false, string jwksJsonData = default(string), string jwksUri = "default_jwks_url", long jwtTtl = 0, string name = default(string), List<string> productType = default(List<string>), List<string> subclaimsDelimiters = default(List<string>), string token = default(string), string uidToken = default(string), string uniqueIdentifier = default(string))
        {
            // to ensure "jwksUri" is required (not null)
            if (jwksUri == null)
            {
                throw new ArgumentNullException("jwksUri is a required property for AuthMethodCreateOauth2 and cannot be null");
            }
            this.JwksUri = jwksUri;
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new ArgumentNullException("name is a required property for AuthMethodCreateOauth2 and cannot be null");
            }
            this.Name = name;
            // to ensure "uniqueIdentifier" is required (not null)
            if (uniqueIdentifier == null)
            {
                throw new ArgumentNullException("uniqueIdentifier is a required property for AuthMethodCreateOauth2 and cannot be null");
            }
            this.UniqueIdentifier = uniqueIdentifier;
            this.AccessExpires = accessExpires;
            this.Audience = audience;
            this.AuditLogsClaims = auditLogsClaims;
            this.BoundClientIds = boundClientIds;
            this.BoundIps = boundIps;
            this.Cert = cert;
            this.CertFileData = certFileData;
            this.Description = description;
            this.ForceSubClaims = forceSubClaims;
            this.GatewayUrl = gatewayUrl;
            this.GwBoundIps = gwBoundIps;
            this.Issuer = issuer;
            this.Json = json;
            this.JwksJsonData = jwksJsonData;
            this.JwtTtl = jwtTtl;
            this.ProductType = productType;
            this.SubclaimsDelimiters = subclaimsDelimiters;
            this.Token = token;
            this.UidToken = uidToken;
        }

        /// <summary>
        /// Access expiration date in Unix timestamp (select 0 for access without expiry date)
        /// </summary>
        /// <value>Access expiration date in Unix timestamp (select 0 for access without expiry date)</value>
        [DataMember(Name = "access-expires", EmitDefaultValue = false)]
        public long AccessExpires { get; set; }

        /// <summary>
        /// The audience in the JWT
        /// </summary>
        /// <value>The audience in the JWT</value>
        [DataMember(Name = "audience", EmitDefaultValue = false)]
        public string Audience { get; set; }

        /// <summary>
        /// Subclaims to include in audit logs, e.g \&quot;- -audit-logs-claims email - -audit-logs-claims username\&quot;
        /// </summary>
        /// <value>Subclaims to include in audit logs, e.g \&quot;- -audit-logs-claims email - -audit-logs-claims username\&quot;</value>
        [DataMember(Name = "audit-logs-claims", EmitDefaultValue = false)]
        public List<string> AuditLogsClaims { get; set; }

        /// <summary>
        /// The clients ids that the access is restricted to
        /// </summary>
        /// <value>The clients ids that the access is restricted to</value>
        [DataMember(Name = "bound-client-ids", EmitDefaultValue = false)]
        public List<string> BoundClientIds { get; set; }

        /// <summary>
        /// A CIDR whitelist with the IPs that the access is restricted to
        /// </summary>
        /// <value>A CIDR whitelist with the IPs that the access is restricted to</value>
        [DataMember(Name = "bound-ips", EmitDefaultValue = false)]
        public List<string> BoundIps { get; set; }

        /// <summary>
        /// CertificateFile Path to a file that contain the certificate in a PEM format.
        /// </summary>
        /// <value>CertificateFile Path to a file that contain the certificate in a PEM format.</value>
        [DataMember(Name = "cert", EmitDefaultValue = false)]
        public string Cert { get; set; }

        /// <summary>
        /// CertificateFileData PEM Certificate in a Base64 format.
        /// </summary>
        /// <value>CertificateFileData PEM Certificate in a Base64 format.</value>
        [DataMember(Name = "cert-file-data", EmitDefaultValue = false)]
        public string CertFileData { get; set; }

        /// <summary>
        /// Auth Method description
        /// </summary>
        /// <value>Auth Method description</value>
        [DataMember(Name = "description", EmitDefaultValue = false)]
        public string Description { get; set; }

        /// <summary>
        /// if true: enforce role-association must include sub claims
        /// </summary>
        /// <value>if true: enforce role-association must include sub claims</value>
        [DataMember(Name = "force-sub-claims", EmitDefaultValue = true)]
        public bool ForceSubClaims { get; set; }

        /// <summary>
        /// Akeyless Gateway URL (Configuration Management port). Relevant only when the jwks-uri is accessible only from the gateway.
        /// </summary>
        /// <value>Akeyless Gateway URL (Configuration Management port). Relevant only when the jwks-uri is accessible only from the gateway.</value>
        [DataMember(Name = "gateway-url", EmitDefaultValue = false)]
        public string GatewayUrl { get; set; }

        /// <summary>
        /// A CIDR whitelist with the GW IPs that the access is restricted to
        /// </summary>
        /// <value>A CIDR whitelist with the GW IPs that the access is restricted to</value>
        [DataMember(Name = "gw-bound-ips", EmitDefaultValue = false)]
        public List<string> GwBoundIps { get; set; }

        /// <summary>
        /// Issuer URL
        /// </summary>
        /// <value>Issuer URL</value>
        [DataMember(Name = "issuer", EmitDefaultValue = false)]
        public string Issuer { get; set; }

        /// <summary>
        /// Set output format to JSON
        /// </summary>
        /// <value>Set output format to JSON</value>
        [DataMember(Name = "json", EmitDefaultValue = true)]
        public bool Json { get; set; }

        /// <summary>
        /// The JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server. base64 encoded string
        /// </summary>
        /// <value>The JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server. base64 encoded string</value>
        [DataMember(Name = "jwks-json-data", EmitDefaultValue = false)]
        public string JwksJsonData { get; set; }

        /// <summary>
        /// The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.
        /// </summary>
        /// <value>The URL to the JSON Web Key Set (JWKS) that containing the public keys that should be used to verify any JSON Web Token (JWT) issued by the authorization server.</value>
        [DataMember(Name = "jwks-uri", IsRequired = true, EmitDefaultValue = true)]
        public string JwksUri { get; set; }

        /// <summary>
        /// Jwt TTL
        /// </summary>
        /// <value>Jwt TTL</value>
        [DataMember(Name = "jwt-ttl", EmitDefaultValue = false)]
        public long JwtTtl { get; set; }

        /// <summary>
        /// Auth Method name
        /// </summary>
        /// <value>Auth Method name</value>
        [DataMember(Name = "name", IsRequired = true, EmitDefaultValue = true)]
        public string Name { get; set; }

        /// <summary>
        /// Choose the relevant product type for the auth method [sm, sra, pm, dp, ca]
        /// </summary>
        /// <value>Choose the relevant product type for the auth method [sm, sra, pm, dp, ca]</value>
        [DataMember(Name = "product-type", EmitDefaultValue = false)]
        public List<string> ProductType { get; set; }

        /// <summary>
        /// A list of additional sub claims delimiters (relevant only for SAML, OIDC, OAuth2/JWT)
        /// </summary>
        /// <value>A list of additional sub claims delimiters (relevant only for SAML, OIDC, OAuth2/JWT)</value>
        [DataMember(Name = "subclaims-delimiters", EmitDefaultValue = false)]
        public List<string> SubclaimsDelimiters { get; set; }

        /// <summary>
        /// Authentication token (see &#x60;/auth&#x60; and &#x60;/configure&#x60;)
        /// </summary>
        /// <value>Authentication token (see &#x60;/auth&#x60; and &#x60;/configure&#x60;)</value>
        [DataMember(Name = "token", EmitDefaultValue = false)]
        public string Token { get; set; }

        /// <summary>
        /// The universal identity token, Required only for universal_identity authentication
        /// </summary>
        /// <value>The universal identity token, Required only for universal_identity authentication</value>
        [DataMember(Name = "uid-token", EmitDefaultValue = false)]
        public string UidToken { get; set; }

        /// <summary>
        /// A unique identifier (ID) value should be configured for OAuth2, LDAP and SAML authentication method types and is usually a value such as the email, username, or upn for example. Whenever a user logs in with a token, these authentication types issue a \&quot;sub claim\&quot; that contains details uniquely identifying that user. This sub claim includes a key containing the ID value that you configured, and is used to distinguish between different users from within the same organization.
        /// </summary>
        /// <value>A unique identifier (ID) value should be configured for OAuth2, LDAP and SAML authentication method types and is usually a value such as the email, username, or upn for example. Whenever a user logs in with a token, these authentication types issue a \&quot;sub claim\&quot; that contains details uniquely identifying that user. This sub claim includes a key containing the ID value that you configured, and is used to distinguish between different users from within the same organization.</value>
        [DataMember(Name = "unique-identifier", IsRequired = true, EmitDefaultValue = true)]
        public string UniqueIdentifier { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class AuthMethodCreateOauth2 {\n");
            sb.Append("  AccessExpires: ").Append(AccessExpires).Append("\n");
            sb.Append("  Audience: ").Append(Audience).Append("\n");
            sb.Append("  AuditLogsClaims: ").Append(AuditLogsClaims).Append("\n");
            sb.Append("  BoundClientIds: ").Append(BoundClientIds).Append("\n");
            sb.Append("  BoundIps: ").Append(BoundIps).Append("\n");
            sb.Append("  Cert: ").Append(Cert).Append("\n");
            sb.Append("  CertFileData: ").Append(CertFileData).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ForceSubClaims: ").Append(ForceSubClaims).Append("\n");
            sb.Append("  GatewayUrl: ").Append(GatewayUrl).Append("\n");
            sb.Append("  GwBoundIps: ").Append(GwBoundIps).Append("\n");
            sb.Append("  Issuer: ").Append(Issuer).Append("\n");
            sb.Append("  Json: ").Append(Json).Append("\n");
            sb.Append("  JwksJsonData: ").Append(JwksJsonData).Append("\n");
            sb.Append("  JwksUri: ").Append(JwksUri).Append("\n");
            sb.Append("  JwtTtl: ").Append(JwtTtl).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  ProductType: ").Append(ProductType).Append("\n");
            sb.Append("  SubclaimsDelimiters: ").Append(SubclaimsDelimiters).Append("\n");
            sb.Append("  Token: ").Append(Token).Append("\n");
            sb.Append("  UidToken: ").Append(UidToken).Append("\n");
            sb.Append("  UniqueIdentifier: ").Append(UniqueIdentifier).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as AuthMethodCreateOauth2);
        }

        /// <summary>
        /// Returns true if AuthMethodCreateOauth2 instances are equal
        /// </summary>
        /// <param name="input">Instance of AuthMethodCreateOauth2 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(AuthMethodCreateOauth2 input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.AccessExpires == input.AccessExpires ||
                    this.AccessExpires.Equals(input.AccessExpires)
                ) && 
                (
                    this.Audience == input.Audience ||
                    (this.Audience != null &&
                    this.Audience.Equals(input.Audience))
                ) && 
                (
                    this.AuditLogsClaims == input.AuditLogsClaims ||
                    this.AuditLogsClaims != null &&
                    input.AuditLogsClaims != null &&
                    this.AuditLogsClaims.SequenceEqual(input.AuditLogsClaims)
                ) && 
                (
                    this.BoundClientIds == input.BoundClientIds ||
                    this.BoundClientIds != null &&
                    input.BoundClientIds != null &&
                    this.BoundClientIds.SequenceEqual(input.BoundClientIds)
                ) && 
                (
                    this.BoundIps == input.BoundIps ||
                    this.BoundIps != null &&
                    input.BoundIps != null &&
                    this.BoundIps.SequenceEqual(input.BoundIps)
                ) && 
                (
                    this.Cert == input.Cert ||
                    (this.Cert != null &&
                    this.Cert.Equals(input.Cert))
                ) && 
                (
                    this.CertFileData == input.CertFileData ||
                    (this.CertFileData != null &&
                    this.CertFileData.Equals(input.CertFileData))
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.ForceSubClaims == input.ForceSubClaims ||
                    this.ForceSubClaims.Equals(input.ForceSubClaims)
                ) && 
                (
                    this.GatewayUrl == input.GatewayUrl ||
                    (this.GatewayUrl != null &&
                    this.GatewayUrl.Equals(input.GatewayUrl))
                ) && 
                (
                    this.GwBoundIps == input.GwBoundIps ||
                    this.GwBoundIps != null &&
                    input.GwBoundIps != null &&
                    this.GwBoundIps.SequenceEqual(input.GwBoundIps)
                ) && 
                (
                    this.Issuer == input.Issuer ||
                    (this.Issuer != null &&
                    this.Issuer.Equals(input.Issuer))
                ) && 
                (
                    this.Json == input.Json ||
                    this.Json.Equals(input.Json)
                ) && 
                (
                    this.JwksJsonData == input.JwksJsonData ||
                    (this.JwksJsonData != null &&
                    this.JwksJsonData.Equals(input.JwksJsonData))
                ) && 
                (
                    this.JwksUri == input.JwksUri ||
                    (this.JwksUri != null &&
                    this.JwksUri.Equals(input.JwksUri))
                ) && 
                (
                    this.JwtTtl == input.JwtTtl ||
                    this.JwtTtl.Equals(input.JwtTtl)
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.ProductType == input.ProductType ||
                    this.ProductType != null &&
                    input.ProductType != null &&
                    this.ProductType.SequenceEqual(input.ProductType)
                ) && 
                (
                    this.SubclaimsDelimiters == input.SubclaimsDelimiters ||
                    this.SubclaimsDelimiters != null &&
                    input.SubclaimsDelimiters != null &&
                    this.SubclaimsDelimiters.SequenceEqual(input.SubclaimsDelimiters)
                ) && 
                (
                    this.Token == input.Token ||
                    (this.Token != null &&
                    this.Token.Equals(input.Token))
                ) && 
                (
                    this.UidToken == input.UidToken ||
                    (this.UidToken != null &&
                    this.UidToken.Equals(input.UidToken))
                ) && 
                (
                    this.UniqueIdentifier == input.UniqueIdentifier ||
                    (this.UniqueIdentifier != null &&
                    this.UniqueIdentifier.Equals(input.UniqueIdentifier))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.AccessExpires.GetHashCode();
                if (this.Audience != null)
                {
                    hashCode = (hashCode * 59) + this.Audience.GetHashCode();
                }
                if (this.AuditLogsClaims != null)
                {
                    hashCode = (hashCode * 59) + this.AuditLogsClaims.GetHashCode();
                }
                if (this.BoundClientIds != null)
                {
                    hashCode = (hashCode * 59) + this.BoundClientIds.GetHashCode();
                }
                if (this.BoundIps != null)
                {
                    hashCode = (hashCode * 59) + this.BoundIps.GetHashCode();
                }
                if (this.Cert != null)
                {
                    hashCode = (hashCode * 59) + this.Cert.GetHashCode();
                }
                if (this.CertFileData != null)
                {
                    hashCode = (hashCode * 59) + this.CertFileData.GetHashCode();
                }
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.ForceSubClaims.GetHashCode();
                if (this.GatewayUrl != null)
                {
                    hashCode = (hashCode * 59) + this.GatewayUrl.GetHashCode();
                }
                if (this.GwBoundIps != null)
                {
                    hashCode = (hashCode * 59) + this.GwBoundIps.GetHashCode();
                }
                if (this.Issuer != null)
                {
                    hashCode = (hashCode * 59) + this.Issuer.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Json.GetHashCode();
                if (this.JwksJsonData != null)
                {
                    hashCode = (hashCode * 59) + this.JwksJsonData.GetHashCode();
                }
                if (this.JwksUri != null)
                {
                    hashCode = (hashCode * 59) + this.JwksUri.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.JwtTtl.GetHashCode();
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.ProductType != null)
                {
                    hashCode = (hashCode * 59) + this.ProductType.GetHashCode();
                }
                if (this.SubclaimsDelimiters != null)
                {
                    hashCode = (hashCode * 59) + this.SubclaimsDelimiters.GetHashCode();
                }
                if (this.Token != null)
                {
                    hashCode = (hashCode * 59) + this.Token.GetHashCode();
                }
                if (this.UidToken != null)
                {
                    hashCode = (hashCode * 59) + this.UidToken.GetHashCode();
                }
                if (this.UniqueIdentifier != null)
                {
                    hashCode = (hashCode * 59) + this.UniqueIdentifier.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
